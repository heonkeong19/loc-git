select * from cust
right outer join ord on cust.고객아이디=ord.주문고객
--주문고객을 기준으로 가져옴. 그래서 2개

select * from cust
left outer join ord on cust.고객아이디=ord.주문고객
--고객아이디 기준으로 가져옴. 그래서 4개

--조인이 많으면 비효율이 초래되는가
--NESTED LOOP
--SELECT를 따로 선언해줘야 하는지 -> 하나의 문장으로 개별개체로 할 수 있는지

select * from cust
select * from ord
SELECT * FROM PRD
--주문제품이 마스터고 제품이름이 슬레이브라고 할 때 제품이름을 코드로 설정하면 안 되는 건가? 
--제품이름은 상표법 때문에 유일하지 않을까?
--제품이름 옆에 코드를 추가하는 방법

--유니온 : 테이블 구조를 맞추는 것

select * from cust
left outer join ord on cust.고객아이디=ord.주문고객
--where cust.나이 >=25
WHERE ORD.주문제품='맛있는파이'

--내가 탈퇴해도 언제 탈퇴했다는 게 이력으로 남아있음. 이벤트 참여기록까지 
--순서에 따라 가져오는 데이터 값이 달라진다.
--어떻게 하면 데이터를 효과적으로 뽑아낼까를 고민하기 -> 데이터가 많으면 많을수록 시간이 많이 걸리기 때문에 효율화가 필요하다


SELECT * FROM PRD
ORDER BY 제품번호
--코드를 숫자로 많이 하는 이유는 숫자가 1바이트라 차지하는 부분이 적기 때문. 한글은 2바이트 -> 효율화의 일종인듯!


--GROUP BY 함수!
--합집합은 분석보고서 쓸 때, 판매순위 등으로 묶어서 전체 가져올 때만//GROUP BY, SUM으로 더 많이 가져옴
--교집합을 많이 씀 -> 왜냐면 조건이 나뉘어지는 게 있기 때문
--차집합: 기준점(마스터)를 어디로 하냐에 따라 데이터가 달라짐 -> 회계정보, 영업정보 등 할 때 기준점이 달라지면 망할 수도
--EX) 1. 비밀번호 안 바꾼 거 체크 2. 휴면계정 체크
--네이버 지식인 엔지니어가 데이터베이스를 튜닝 -> 속도가 잘 나오고 유사질문을 보여주는 기능을 만듦. -> 교집합, 합집합, 자연어처리, 연관어처리
